/*
            Библиотека функций быстрого доступа к данным для архитектуры «Эльбрус» («ЭЛЬФ»
  Функция создания двух результирующих векторов  по правилу P&Q
	int pq_gen(int vects, int len, void **array);
 где:
	vects — кол-во векторов источников, включая два вектора результата;
	len — длина каждого вектора в байтах;
	array — указатель на массивы векторов источников и векторов P и Q результата. 
    Алгоритм.
Вычисляется вектор результата P (как и в п.1.2) по формуле:
P = V1 ^ V2 ^ …^ Vn 
   где: Vi - вектора - источники (i = 1, n);
             n = vects-2;
            P – вектор результата.
            ^ - операция xor, выполняемая над векторами поэлементно.
Вектор результата P помещается последним в массиве array. 
Вектор Q рассчитывается с использованием генератора g по формуле:
Q[k] = g0D0 + g1D1 + g2D2 + ::: + gN-1DN-1
где g выбирается как {2}, второй элемент поля. Операция умножения и поле определяются с помощью порождающего полинома x8 + x4 + x3 + x2 + 1   (0x1d).
Вектор результата Q помещается предпоследним в массиве array. 
Для повышения скорости работы функции рекомендуется использовать длину массивов векторов кратной 32 байтам.
Результирующие вектора  помещаются последними в массив array.
Для повышения скорости работы функции рекомендуется использовать длину массивов векторов кратной 32 байтам. 
Данная функция возвращает: 0 в случае нормального завершения и -1, если vects – (количество векторов) меньше 3.
Ненулевое значение сигнализирует о наличии ошибок в процессе выполнения.
*/

#include "raid.h"
#include <limits.h>
#include <stdint.h>

#define notbit0 0xfefefefefefefefeULL
#define bit7    0x8080808080808080ULL
#define gf8poly 0x1d1d1d1d1d1d1d1dULL

int pq_gen(int vects, int len, void **array) {
    int i, j;
    unsigned long p, q, s;
    unsigned long **src = (unsigned long **) array;
    int blocks = len / sizeof (long);
    if (vects < 3) return -1;

    for (i = 0; i < blocks; i++) {
        q = p = src[vects - 3][i];

        for (j = vects - 4; j >= 0; j--) {
            p ^= s = src[j][i];
            q = s ^ (((q << 1) & notbit0) ^ // shift each byte
                    ((((q & bit7) << 1) - ((q & bit7) >> 7)) // mask out bytes
                    & gf8poly)); // apply poly
        }

        src[vects - 2][i] = p; // second to last pointer is p
        src[vects - 1][i] = q; // last pointer is q
    }
    return 0;
}

/*
            Библиотека функций быстрого доступа к данным для архитектуры «Эльбрус» («ЭЛЬФ»)
 Функция проверки согласованности двух результирующих векторов полученных по правилу P&Q с массивом векторов - источников.
	int pq_check (int vects, int len, void **array);
 где:
	- vects — кол-во векторов источников и два вектора результата;
	- len — длина каждого вектора в байтах;
	- array — указатель на массивы векторов источников и векторов P и Q результата. 

	Алгоритм.
Побайтно вычисляется вектор результата P по формуле:
P[k]  = V1[k] ^ V2[k] ^ …^ Vn[k]
   где: Vi - вектора - источники (i = 1, n);
             n = vects-2;
            P – вектор результата.
            ^ - операция xor, выполняемая над векторами поэлементно.
Побайтно рассчитывается вектор Q с использованием генератора g по формуле:
Q[k]  = g0V1[k] + g1V2[k] + g2V3[k] + ::: + gN-1VN-1[k]  
где g выбирается как {2}, второй элемент поля. Операция умножения и поле определяются с помощью порождающего полинома x8 + x4 + x3 + x2 + 1   (0x1d).
Для повышения скорости работы функции рекомендуется использовать длину массивов векторов кратной 32 байтам.
Данная функция возвращает 0 в случае, если результаты P[k]  и Q[k] для всех колонок равны 0.
Функция возвращает -1 в случае, если vects – (количество векторов) меньше 3.
Как только вычисление результата P или Q для k-й колонки даст не 0, дальнейшие проверки прекращаются и производится выход из функции со значением выхода больше нуля, при этом ненулевой бит 0 результата свидетельствует о наличии несоответствия по Р – вектору, а ненулевой бит 1 результата свидетельствует о наличии несоответствия по Q – вектору.
*/

#include "raid.h"
#include <limits.h>
#include <stdint.h>

#define notbit0 0xfefefefefefefefeULL
#define bit7 0x8080808080808080ULL
#define gf8poly 0x1d1d1d1d1d1d1d1dULL

int pq_check(int vects, int len, void **array)
{
	int i, j;
	unsigned char p, q, s;
	unsigned char **src = (unsigned char **)array;
	if (vects < 3)
		return -1;
	for (i = 0; i < len; i++)
	{
		q = p = src[vects - 3][i];

		for (j = vects - 4; j >= 0; j--)
		{
			s = src[j][i];
			p ^= s;

			// mult by GF{2}
			q = s ^ ((q << 1) ^ ((q & 0x80) ? 0x1d : 0));
		}

		if (src[vects - 2][i] != p) // second to last pointer is p
			return i | 1;
		if (src[vects - 1][i] != q) // last pointer is q
			return i | 2;
	}
	return 0;
}
